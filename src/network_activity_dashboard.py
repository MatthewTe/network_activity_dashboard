# Importing dash packages:
import dash
import dash_bootstrap_components as dbc
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
import dash_table
# Importing internal methods used to create and maintain datastreams:
from network_data_api import network_api
# Importing data management packages:
import pandas as pd
from collections import deque
import time
# Importing data visualization packages:
import plotly.graph_objects as go



# Add network api method that builds and returns a list of deques based on detectable NICs

# Creating main dash object:
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.DARKLY])

# Defining the layout of the Dash applications:
app.layout = html.Div(children=[

    # Dashboard Header Div Tag:
    html.Div(children = [

        # Main Navigation bar:
        dbc.Navbar(
            children=[

            # Formatting of the Navbar:
            html.A([

                # The header row of the dashboard:
                dbc.Row(

                    # The Navbar Title, NIC and Socket Drop:
                    dbc.Col(html.H1('Network Usage Dashboard')),
                    align = 'center'
                    ),

                # NIC Button used to select dashboard tab:
                dbc.Button('Network Interface Cards', id='NIC_dash', n_clicks_timestamp=0 ,className="mr-1"),

                # Sockets Button used to select dashboard tab:
                dbc.Button('Network Sockets', id='sockets_dash', n_clicks_timestamp=0 ,className="mr-1")
                ])

            ],
            id = 'dash_navbar'
            )
        ]),

    # Div Tag that will contain all the div tags generated by the @callback
    # Based on Button clicks in the Header Div Tag:
    html.Div(id='dash_navbar_response')
])
app.config.suppress_callback_exceptions = True
# The main callbacks the modify the dashboard based on the main Buttons:

# Button Callback, determines which tab of the dashboard is displayed:
@app.callback(
    Output(component_id='dash_navbar_response', component_property='children'),
    [Input(component_id='NIC_dash', component_property='n_clicks_timestamp'),
     Input(component_id='sockets_dash', component_property='n_clicks_timestamp')]
)
def build_nic_dash(nic_timestamp, socket_timestamp):
    '''
    Method is used to format the dash_navbar_response Div tag based on the most
    recently pressed Button in the navigation bar. It serves as a means of switching
    between tabs of the dashboard based on the values of click timestamps provided
    by the bootstrap button functionality. The process by which the most recently
    pressed button is determined is based on a user response:

    https://community.plotly.com/t/input-two-or-more-button-how-to-tell-which-
    button-is-pressed/5788/29

    Parameters
    ----------
    nic_timestamp : int
        An integer that represents the time in ms at which the number of clicks
        the NIC_dash button is changed.

    socket_timestamp : int
        An integer that represents the time in ms at which the number of clicks
        the sockets_dash button is changed.

    Returns
    -------
    children : lst
        A list of html Div children that will be inserted as children in the
        dash_navbar_response main Div tag.
    '''
    # If the NIC Button is pressed most recently:
    if int(nic_timestamp) > int(socket_timestamp):

        # List of dash_navbar_response children that will be built via iteration:
        children = []

        # Extracting the list of NIC names:
        api_data = network_api()
        nic_names = network_api.get_nic_names()

        # The first child, the NIC data summary DataTable nested in format div:
        fst_data_tbl = dash_table.DataTable(
            id = 'main_tbl',
            columns = [{'name': i, 'id': i} for i in api_data.nic_main_df.columns],
            data = api_data.nic_main_df.to_dict('records'),
            # Table Styling:
            style_header={'backgroundColor': 'rgb(30, 30, 30)'},
            style_cell = {
                'textAlign': 'left',
                'backgroundColor': 'rgb(50, 50, 50)',
                'color': 'white',
                'minWidth': '180px', 'width': '180px', 'maxWidth': '180px'
                },
            #TODO: Add Styling cells based on data conditionals:
            )

        # fst_data_tbl format Div:
        main_tbl_div = html.Div(
            children=[
                html.H3('Network Interface Card Summary:'),
                fst_data_tbl
                ],
            id = 'main_tbl_div',
            style = {'padding': '20px'}
            )

        # Adding the first DataTable to the list of children:
        children.append(main_tbl_div)

        # Creating the dcc.graph object and the interval object that will be added to children:
        live_network_graph = dcc.Graph(id='nic_live_graph', animate=True)
        live_network_graph_interval = dcc.Interval(
            id = 'nic_live_graph_update',
            interval = 1000,
            n_intervals = 0
        )

        # Adding live graph and interval object to the list of children:
        children.append(live_network_graph)
        children.append(live_network_graph_interval)


        # Iterating through the list of NICs and building custom data tables:
        for name in api_data.nic_names:

            # Building dataframe of NIC address info based on each NIC:
            addr_df = network_api.build_net_if_addrs_df(name)

            # Building data table object:
            nic_info_tbl = dash_table.DataTable(
                id = f'{name}_addr_tbl',
                columns = [{'name': i, 'id': i} for i in addr_df.columns],
                data = addr_df.to_dict('records'),
                # Table Styling:
                style_data = {
                    'height': 'auto',
                    'whiteSpace' : 'normal'
                },
                style_header={'backgroundColor': 'rgb(30, 30, 30)'},
                style_cell = {
                    'textAlign': 'left',
                    'backgroundColor': 'rgb(50, 50, 50)',
                    'color': 'white',
                    'minWidth': '180px', 'width': '180px', 'maxWidth': '180px'
                    }
                )

            # Nesting the data table into a formatting div tag:
            format_div = html.Div(
                children = [
                    html.H5(f'Address Information for NIC: {name}'),
                    nic_info_tbl
                    ],
                id = f'{name}_addr_div',
                style = {
                    'width': 'auto',
                    'padding': '20px'}
            )

            children.append(format_div)

            # TODO: Find out a div pushing system that builds inline [table: network graph] 

        return children



    # If the Socket Button is pressed most recently:
    elif int(socket_timestamp) > int(nic_timestamp):

        return html.H1('Socket CALLBACK SET')

# Method that encapsulates the callback method that cont. updates the graphs when called:
def perform_update(name):
    '''
    A wrapper method that executes the live update ability for each NIC. This method
    serves as a wrapper method so that concurrency can be added to the Dash.

    Parameters
    nic_name : str
        The name of the Network Interface Card
    '''
    @app.callback(
        Output(component_id= f'live-{name}-graph', component_property='figure'),
        [Input(component_id= f'live-{name}-graph-update', component_property='n_intervals')]
    )
    def update_nic_graph(n):
        '''
        Method uses the callback above to update each dynamically generated graph
        object based on the name of the NIC and the id of the previously generated
        dcc.Graph objects by the previous callback.

        Parameters
        ----------
        n : int
            A "dummy" variable that represents the continuous output of the dcc.interval
            object. Triggers an event every time n in input into the method

        Returns
        -------
        fig : plotly graph object
            The go.Figure object representing the formatted and continuously updated
            plotly graph of network data.
        '''
        # Unpacking current NIC data:
        sent, recv, p_sent, p_recv, errin, errout, dropin, dropout = network_api.get_nic_info(name)

        # Updating the global deques:
        timestamp = int(round(time.time()*1000))
        X.append(timestamp)
        Y.append(sent)

        data = go.Scatter(
            x = list(X),
            y = list(Y),
            mode = 'lines'
            )

        layout = go.Layout(
            title = go.layout.Title(text= f'NIC: {name}')
        )


        fig = go.Figure(data=data, layout=layout)
        fig.update_xaxes(range= [min(X), max(X)])
        fig.update_yaxes(range= [min(Y), max(Y)+5000])

        return fig



if __name__ == '__main__':
    app.run_server(debug=True)
