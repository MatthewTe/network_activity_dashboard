# Importing dash packages:
import dash
import dash_bootstrap_components as dbc
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
import dash_table
# Importing internal methods used to create and maintain datastreams:
from network_data_api import network_api, netwrk_data_structs
# Importing data management packages:
import pandas as pd
from collections import deque
import time
# Importing data visualization packages:
import plotly.graph_objects as go
from plotly.subplots import make_subplots



# Add network api method that builds and returns a list of deques based on detectable NICs

# Creating main dash object:
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.DARKLY])

# Initalizing the data structs objects:
api_data = network_api()
data_structs = netwrk_data_structs()
# Declaring global y-axis deque:
X = deque(maxlen=20)
X.append(1)


# Defining the layout of the Dash applications:
app.layout = html.Div(children=[

    # Dashboard Header Div Tag:
    html.Div(children = [

        # Main Navigation bar:
        dbc.Navbar(
            children=[

            # Formatting of the Navbar:
            html.A([

                # The header row of the dashboard:
                dbc.Row(

                    # The Navbar Title, NIC and Socket Drop:
                    dbc.Col(html.H1('Network Usage Dashboard')),
                    align = 'center'
                    ),

                # NIC Button used to select dashboard tab:
                dbc.Button('Network Interface Cards', id='NIC_dash', n_clicks_timestamp=0 ,className="mr-1"),

                # Sockets Button used to select dashboard tab:
                dbc.Button('Network Sockets', id='sockets_dash', n_clicks_timestamp=0 ,className="mr-1")
                ])

            ],
            id = 'dash_navbar'
            )
        ]),

    # Div Tag that will contain all the div tags generated by the @callback
    # Based on Button clicks in the Header Div Tag:
    html.Div(id='dash_navbar_response')
])
app.config.suppress_callback_exceptions = True
# The main callbacks the modify the dashboard based on the main Buttons:

# Button Callback, determines which tab of the dashboard is displayed:
@app.callback(
    Output(component_id='dash_navbar_response', component_property='children'),
    [Input(component_id='NIC_dash', component_property='n_clicks_timestamp'),
     Input(component_id='sockets_dash', component_property='n_clicks_timestamp')]
)
def build_nic_dash(nic_timestamp, socket_timestamp):
    '''
    Method is used to format the dash_navbar_response Div tag based on the most
    recently pressed Button in the navigation bar. It serves as a means of switching
    between tabs of the dashboard based on the values of click timestamps provided
    by the bootstrap button functionality. The process by which the most recently
    pressed button is determined is based on a user response:

    https://community.plotly.com/t/input-two-or-more-button-how-to-tell-which-
    button-is-pressed/5788/29

    Parameters
    ----------
    nic_timestamp : int
        An integer that represents the time in ms at which the number of clicks
        the NIC_dash button is changed.

    socket_timestamp : int
        An integer that represents the time in ms at which the number of clicks
        the sockets_dash button is changed.

    Returns
    -------
    children : lst
        A list of html Div children that will be inserted as children in the
        dash_navbar_response main Div tag.
    '''
    # If the NIC Button is pressed most recently:
    if int(nic_timestamp) > int(socket_timestamp):

        # List of dash_navbar_response children that will be built via iteration:
        children = []

        # Extracting the list of NIC names:
        nic_names = network_api.get_nic_names()

        # The first child, the NIC data summary DataTable nested in format div:
        fst_data_tbl = dash_table.DataTable(
            id = 'main_tbl',
            columns = [{'name': i, 'id': i} for i in api_data.nic_main_df.columns],
            data = api_data.nic_main_df.to_dict('records'),
            # Table Styling:
            style_header={'backgroundColor': 'rgb(30, 30, 30)'},
            style_cell = {
                'textAlign': 'left',
                'backgroundColor': 'rgb(50, 50, 50)',
                'color': 'white',
                'minWidth': '180px', 'width': '180px', 'maxWidth': '180px'
                },
            #TODO: Add Styling cells based on data conditionals:
            )

        # fst_data_tbl format Div:
        main_tbl_div = html.Div(
            children=[
                html.H3('Network Interface Card Summary:'),
                fst_data_tbl
                ],
            id = 'main_tbl_div',
            style = {'padding': '20px'}
            )

        # Adding the first DataTable to the list of children:
        children.append(main_tbl_div)

        # Creating an interval object for live graph update calls via callback:
        live_network_graph_interval = dcc.Interval(
            id = 'live_graph_update',
            interval = 2000,
            n_intervals = 0
            )
        children.append(live_network_graph_interval)


        # Iterating through the list of NICs and building custom data tables:
        for name in api_data.nic_names:

            # Creating the main htm.Div tag i

            # Building dataframe of NIC address info based on each NIC:
            addr_df = network_api.build_net_if_addrs_df(name)

            # Building data table object:
            nic_info_tbl = dash_table.DataTable(
                id = f'{name}_addr_tbl',
                columns = [{'name': i, 'id': i} for i in addr_df.columns],
                data = addr_df.to_dict('records'),
                # Table Styling:
                style_data = {
                    'height': 'auto',
                    'whiteSpace' : 'normal'
                },
                style_header={'backgroundColor': 'rgb(30, 30, 30)'},
                style_cell = {
                    'textAlign': 'left',
                    'backgroundColor': 'rgb(50, 50, 50)',
                    'color': 'white',
                    'minWidth': '180px', 'width': '180px', 'maxWidth': '180px'
                    }
                )

            # Creating the live graphs displaying Network activity data for each NIC:
            live_network_graph = dcc.Graph(id=f'{name}_live_graph', animate=True)
            live_network_graph_div = html.Div(
                children = [live_network_graph],
                id = f'{name}_live_graph_div',
                style = {
                    'width': 'auto',
                    'padding': '20px'}
            )

            # Nesting the data table into a formatting div tag:
            format_div = html.Div(
                children = [
                    html.H5(f'Address Information for NIC: {name}'),
                    nic_info_tbl,
                    live_network_graph_div
                    ],
                id = f'{name}_addr_div',
                style = {
                    'width': 'auto',
                    'padding': '20px'}
            )

            children.append(format_div)

        return children



    # If the Socket Button is pressed most recently:
    elif int(socket_timestamp) > int(nic_timestamp):

        return html.H1('Socket CALLBACK SET')


# Callback that updates the nic_live_graph based on the Interval object:
@app.callback(
    data_structs.graph_callback_outputs, # <- dynamically building list of graph outputs
    [Input(component_id='live_graph_update', component_property='n_intervals')]
)
def update_nic_graph(n):
    # TODO: Add documentation

    # Creating the list of figures that will be returned to the callback input:
    fig_lst = []

    X.append(X[-1] + 1)
    # Iterating through the list of NIC names and building each figure:
    for name in api_data.nic_names:

        # Unpacking the most recent network transmition information:
        (bytes_sent, bytes_recv, packets_sent, packets_recv, errin, errout,
            dropin, dropout) = network_api.get_nic_counter(name)

        # Updating the data stored in the deques created by the data_structs obj:
        data_structs.nic_deques[name]['packets_sent'].append(packets_sent)
        data_structs.nic_deques[name]['packets_recv'].append(packets_recv)
        data_structs.nic_deques[name]['dropin'].append(dropin)
        data_structs.nic_deques[name]['dropout'].append(dropout)



        # Creating main figure with subplots to be updated:
        fig = make_subplots(
            # Declaring the dimensions of the subplots:
            rows = 2, cols = 2,
            specs = [
                [{}, {}],
                [{}, {}],

            ],
            subplot_titles = (
                'Packets Sent', 'Packets Received',
                'Dropped Incoming Packets', 'Dropped Outgoing Packets'
                )
            )

        # Increasing size of the whole figure to support the number of subplots:
        fig['layout'].update(height=1000)
        fig.update_layout(
            template='plotly_dark',
            showlegend=False,
            autosize=True,
            title_text = f'{name} Live Network Feed')
        fig.update_xaxes(showline=True, linewidth=2, mirror=True)
        fig.update_yaxes(showline=True, linewidth=2, mirror=True)


        # Adding and formatting trace for number of packets sent:
        fig.add_trace(
            go.Scatter(
                x=list(X),
                y=list(data_structs.nic_deques[name]['packets_sent']),
                name = 'Scatter',
                mode = 'lines+markers',
                line = dict(color= '#00FF00')
                ),
            row = 1,
            col = 1
        )
        fig.update_yaxes(
            range=[
                min(data_structs.nic_deques[name]['packets_sent']),
                max(data_structs.nic_deques[name]['packets_sent']) + 100
                ],
            row = 1,
            col = 1,
            automargin = True
            )
        fig.update_xaxes(
            range = [
                min(X),
                max(X) + 30
            ],
            row = 1,
            col = 1
        )

        # Adding and formatting trace for number of packets recieved:
        fig.add_trace(
            go.Scatter(
                x=list(X),
                y=list(data_structs.nic_deques[name]['packets_recv']),
                name = 'Scatter',
                mode = 'lines+markers',
                line = dict(color= '#00FF00')
                ),
            row = 1,
            col = 2
        )
        fig.update_yaxes(
            range=[
                min(data_structs.nic_deques[name]['packets_recv']),
                max(data_structs.nic_deques[name]['packets_recv']) + 100
                ],
            row = 1,
            col = 2,
            automargin = True
            )
        fig.update_xaxes(
            range = [
                min(X),
                max(X) + 30
            ],
            row = 1,
            col = 2
        )

        # Adding and formatting trace for number of incoming packets dropped:
        fig.add_trace(
            go.Scatter(
                x=list(X),
                y=list(data_structs.nic_deques[name]['dropin']),
                name = 'Scatter',
                mode = 'lines+markers',
                line = dict(color= '#FF0000')
                ),
            row = 2,
            col = 1
        )
        fig.update_yaxes(
            range=[
                min(data_structs.nic_deques[name]['dropin']),
                max(data_structs.nic_deques[name]['dropin']) + 100
                ],
            row = 2,
            col = 1,
            automargin = True
            )
        fig.update_xaxes(
            range = [
                min(X),
                max(X) + 30
            ],
            row = 2,
            col = 1
        )

        # Adding and formatting trace for number of outgoing packets dropped:
        fig.add_trace(
            go.Scatter(
                x=list(X),
                y=list(data_structs.nic_deques[name]['dropout']),
                name = 'Scatter',
                mode = 'lines+markers',
                line = dict(color= '#FF0000')
                ),
            row = 2,
            col = 2
        )
        fig.update_yaxes(
            range=[
                min(data_structs.nic_deques[name]['dropout']),
                max(data_structs.nic_deques[name]['dropout']) + 100
                ],
            row = 2,
            col = 2,
            automargin = True
            )
        fig.update_xaxes(
            range = [
                min(X),
                max(X) + 30
            ],
            row = 2,
            col = 2
        )

        # Appending figure to the main list of figures:
        fig_lst.append(fig)


    return fig_lst



if __name__ == '__main__':
    app.run_server(debug=True)

# TODO: Format, add Comments, Docs and a README
